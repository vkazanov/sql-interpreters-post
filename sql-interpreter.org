* Аннотация

  Реляционные базы данных - современный де факто стандарт хранения, обработки и доступа к данным.
  Масштаб таких БД простирается от небольших встроенных в процесс приложения [[https://sqlite.org][библиотек]] до
  распределенных [[https://hive.apache.org][систем]] в сотни машин.

  Внутреннее устройство конкретных баз данных может сильно различаться в зависимости от множества
  факторов: объема данных, требуемой производительности разных видов запросов, ключевых
  архитектурных решений. Объединяет же эти базы данных реляционная модель и интерфейс доступа к
  данным - язык SQL.

  Данная статья рассматривает основы реляционной алгебры, ее связь с языком SQL и описывает
  реализацию интерпретатора небольшого диалекта SQL. На базе интерпретатора-примера объясняются
  более современные подходы к компиляции и интерпретации SQL.

* Исторический обзор: реляционная алгебра и SQL

  Реляционная модель данных была предложена Эдгаром Коддом в 1970 году^{[[link-rel-algebra-paper]]} во
  время работы в одной из исследовательских групп компании IBM. Вместе с моделью Кодд разработал
  язык для работы с данными - реляционную алгебру. Модель и сопутствующая алгебра в первые годы
  после публикации не получили распространения в СУБД от IBM.

  Несмотря на это Кодд активно занимался популяризацией своих идей, и на одной из презентаций с его
  работами познакомились Реймонд Бойс и Дональд Чемберлен, занимавшиеся тогда исследованиями в
  области языков запросов для СУБД. Идеи Кодда показались им перспективными, но ориентированными на
  математиков. Поэтому ученые занялись альтеративным реляционной алгебре языком запросов и результат
  своих исследований - язык Sequel - опубликовали в 1974 году^{[[link-sequel-paper]]}. Позже из-за конфликта имен с других
  языком программирования Sequel получил современное название SQL^{[[link-sql-history-paper]]}.

  Новый язык и соответствующая ему модель данных были выбраны в качестве основных разработчиками еще
  одного проекта IBM - исследовательской СУБД System R^{[[link-system-r-paper]]}, разработка которой велась
  в середине 70-х. System R стала моделью для множества успешных сторонних коммерческих и
  собственной реляционной СУБД компании IBM - DB2. Уже в 1984 годы был опубликован первый стандарт
  языка SQL. Язык SQL стал современным стандартом в области работы с данными.

  Модель данных SQL упрощает и видоизменяет исходную реляционную модель данных, за что ее долго
  критиковал сам Кодд; но удивительным образом в современных БД нашли свое место и ключевые элементы
  реляционной алгебры, и декларативный SQL, что можно будет увидеть в интерпретаторе-примере.

* Проблемы традиционных СУБД и традиционные интерпретаторы

  Любая промышленная СУБД решает типовые задачи: управление памятью, проблемы параллельного доступа
  к данным, изоляция транзакций и исполнение запросов пользователей.

  Традиционно производительность БД упирается в скорость чтения данных с медленных и объемных
  накопителей, куда помещаются все пользовательские данные. Быстрое же ОЗУ, с которым работает
  процессор, имеет ограниченный объем. Выбором данных для помещения в буфер ОЗУ в БД занимаются
  подсистемы управления буфером (англ. buffer manager или page cache). Простейшие базы эту задачу
  перекладывают на операционную систему при помощи системного вызова mmap.

  В условиях, когда большую часть времени обработки запроса занимает ввод-вывод, не так важна
  производительность выполнения самого запроса, поэтому до недавних пор сами интерпретаторы запросов
  были устроены относительно просто.

  # TODO: a picture

  Например, в типичных СУБД, поддерживающих стандарт SQL, из запроса сначала формируется древовидное
  внутреннее представление в терминах логической алгебры. Логическая алгебра примерно соответствует
  реляционной алгебре Кода, для нее существует множество упрощающих правил и эвристик, которые и
  использует первый этап работы оптимизирующей запросы пользователей подсистемы.

  В компиляторах языков общего назначения этому этапу условно соответствуют простейшие оптимизации на
  выражениях (свертка констант, удаление мертвого кода и так далее).

  На втором этапе работы оптимизатора выбираются конкретные алгоритмы, реализующие операторы
  логической алгебры. В результате из представления в форме логической алгебры получается
  представление в виде физической алгебры.

  Физическая алгебра - древовидное представление, которое непосредственно может выполняться
  интерпретатором запросов, без дополнительной обработки.

* Реляционная алгебра на пальцах

  Логическая алгебра, в которую компилируются запросы традиционных БД, во многом схожа с реляционной
  алгеброй Кодда, поэтому для понимания принципов работы интерпретаторов SQL, надо иметь хотя бы
  базовое понимание модели реляционной алгебры.

  Реляционная алгебра состоит из /операторов/, определенных для /отношений/.

  Отношение представляет собой множество /атрибутов/ отношения (/заголовок/ отношения) и множество
  /кортежей/ (/тело/ отношения). Каждый атрибут в заголовке это пара имя-тип. Все кортежи в теле
  отношения содержат значения типов, определенных в соответствующих атрибутах заголовка.

  Каждый оператор выполняет действие над одним и более отношениями; результат работы оператора -
  новое отношение.

  В SQL отношения соответствуют - с некоторыми оговорками - /таблицам/, атрибуты отношений - /колонкам/,
  а кортежи - /рядам/ в этих таблицах.

  Примеры простейших операторов:

  1. Выборка (англ. select).

  2. Проекция (англ. project).

  3. Переименование (англ. rename).

  4. Объединение (англ. union).

  Аргументы оператора /выборки/ - существующее отношение и предикат на атрибутах отношения. Результат
  работы оператора - новое отношение, для значений атрибутов кортежей которого верен предикат.

  Оператор /проекции/ берет существующее отношение, и возвращает отношение со всеми кортежами, но
  только подмножеством атрибутов.

  Оператор /переименования/ меняет имена атрибутов.

  Оператор /объединения/, как можно догадаться, объединяет два отношения в одно.

  Естественно, что существует множество других операторов. Некоторые интересные отличия SQL от
  реляционной алгебры: результат работы операторов может быть упорядочен оператором сортировки;
  таблицы - не обязательно множества, то есть значения колонок в разных рядах могут повторяться.

  Простейший запрос:

  #+BEGIN_EXAMPLE
  SELECT column1 FROM table1 WHERE column1 > 10 ORDER BY column1;
  #+END_EXAMPLE

  Соответствующие ему операторы логической алгебры:

  #+BEGIN_EXAMPLE
  sort(project(select(scan(table1), column1>10), column1), column1)
  #+END_EXAMPLE

  Оператор /сканирования/ (англ. /scan/) просто выбирает кортежи из таблицы table1; select выбирает
  кортежи, для которых верен предикат column1>10; project оставляет в кортежах только атрибут
  column1, а оператор sort возвращает таблицу с упорядоченными по атрибуту column1 рядами.

* Модель Volcano на итераторах

  После компиляции SQL в дерево операторов логической алгебры, этапа оптимизации и выбора операторов
  физической алгебры получившийся древовидный план запроса надо выполнить. В традиционных БД,
  ориентированных на размещение данных на медленных емких постоянных носителях, быстрое выполнение
  запроса процессором менее важно, чем сведение к минимуму количества операций ввода-вывода. В такой
  архитектуре дерево операторов физической алгебры можно исполнить без дополнительных
  преобразований.

  Интерпретаторы дерева физической алгебры в закрытых коммерческих БД использовались практически
  всегда, но ключевая публикация на эту тему связана с экспериментальным оптимизатором
  Volcano^{[[link-volcano-paper]]}, разрабатывавшемся в начале 90-х.

  В модели Volcano операторы превращаются в структуры с тремя функциями: open, next, close. Кроме
  функций оператор содержит рабочее состояние - state. Функция open инициирует состояние оператора,
  next возвращает либо следующий кортеж, либо NULL если кортежей большей не осталось. Функция close
  деаллоцирует рабочее состояние.

  Каждый оператор, таким образом, перебирает кортежи какого-либо
  постоянно существующего отношения, либо отношения, формируемого перебором кортежей дочерних
  операторов.

  # TODO: picture

  Операторы могут быть вложены друг в друга, чтобы сформировать дерево операторов. В терминах
  современных языков высокого уровня дерево таких операторов представляет собой каскад интераторов.

* PigletQL

  От модели Volcano отталкиваются даже более развитые интерпретаторы и компиляторы запросов в
  реляционных СУБД, поэтому в качестве иллюстрации к статье я разработал небольшой интерпретатор
  языка запросов, напоминающего SQL - PigletQL.

  Язык этот поддерживает создание таблиц в стиле SQL, но ограничивается единственным типом -
  32-битными положительными целыми числами. Все таблицы располагаются в памяти. Система работает в
  один поток и не предлагает механизма транзакций.

  В PigletQL (TODO: link) нет оптимизатора, и запросы SELECT компилируются прямо в дерево операторов.

  К таблицам можно выполнять запросы, соответствующие простейшим операторам физической алгебры: scan,
  project, select, join, sort.

  Пример сессии PigletQL:

  #+BEGIN_EXAMPLE
  > ./pigletql
  > CREATE TABLE tab1 (col1,col2,col3);
  > INSERT INTO tab1 VALUES (1,2,3);
  > INSERT INTO tab1 VALUES (4,5,6);
  > SELECT col1,col2,col3 FROM tab1;
  col1 col2 col3
  1 2 3
  4 5 6
  rows: 2
  > SELECT col1 FROM tab1 ORDER BY col1 DESC;
  col1
  4
  1
  rows: 2
  #+END_EXAMPLE

*** Отношения и кортежи

    Простейшие сущности в PigletQL: отношения (англ. relations) и кортежи (англ. tuples).

    Отношения это плоские таблицы, создаваемые с заданным количеством атрибутов (функция relation_create) или с
    атрибутами, позаимствованными у кортежа (TODO: функция relation_create_for_tuple):

    #+BEGIN_SRC c

      /* see pigletql-eval.h */
      typedef struct relation_t relation_t;

      relation_t *relation_create(const attr_name_t *attr_names, const uint16_t attr_num);

      relation_t *relation_create_for_tuple(const tuple_t *tuple);

      /* see pigletql-eval.c */
      struct relation_t {
          attr_name_t attr_names[MAX_ATTR_NUM];
          uint16_t attr_num;

          value_type_t *tuples;
          uint32_t tuple_num;
          uint32_t tuple_slots;
      };

    #+END_SRC

    Кортежи устроены несколько сложнее, напрямую их создать нельзя, а можно только получить из
    оператора, перебирающего кортежи либо отношения-источника, либо вложенного оператора:

    #+BEGIN_SRC c
      /* see pigletql-eval.h */
      typedef struct tuple_t tuple_t;

      /* see pigletql-eval.c */

      typedef enum tuple_tag {
          TUPLE_SOURCE,
          TUPLE_PROJECT,
          TUPLE_JOIN
      } tuple_tag;

      /* A unified tuple type passed between operators */
      struct tuple_t {
          tuple_tag tag;
          union {
              tuple_source_t source;
              tuple_project_t project;
              tuple_join_t join;
          } as;
      };

      /* Source tuple is a reference to raw data in the relations */
      typedef struct tuple_source_t {
          /* A reference to a relation containing the tuple */
          const relation_t *relation;
          /* A reference to the values in the relation containing the tuple */
          uint32_t tuple_i;
      } tuple_source_t;

      /* A projected tuple is a reference to another tuple giving access to a subset of referenced tuple
       * attributes only */
      typedef struct tuple_project_t {
          /* a reference to tuple to project attributes from  */
          tuple_t *source_tuple;
          /* projected attributes */
          attr_name_t attr_names[MAX_ATTR_NUM];
          uint16_t attr_num;
      } tuple_project_t;

      /* A joined tuple is a tuple containing attributes from 2 source tuples  */
      typedef struct tuple_join_t {
          /* Contained tuples to join attributes from */
          tuple_t *left_source_tuple;
          tuple_t *right_source_tuple;
      } tuple_join_t;

    #+END_SRC

    Кортежи в PigletQL бывают трех видов: непосредственно ссылающиеся на данные в отношении
    (tuple_source_t), ограничивающие список доступных атрибутов (tuple_project_t) и соединяющие
    атрибуты из двух вложенных кортежей (tuple_join_t). Функции, обращающиеся к значениями
    атрибутов, работают по-разному для каждого из видов кортежей в зависимости от тега кортежа.

    Вот, например, функция (TODO:), получающее значение атрибута в кортеже:

    #+BEGIN_SRC c
    /* see pigletql-eval.h */

    value_type_t tuple_get_attr_value(const tuple_t *tuple, const attr_name_t attr_name);

    /* see pigletql-eval.c */

    value_type_t tuple_get_attr_value(const tuple_t *tuple, const attr_name_t attr_name)
    {
        if (tuple->tag == TUPLE_SOURCE)
            return tuple_source_get_attr_value(&tuple->as.source, attr_name);
        else if (tuple->tag == TUPLE_PROJECT)
            return tuple_project_get_attr_value(&tuple->as.project, attr_name);
        else if (tuple->tag == TUPLE_JOIN)
            return tuple_join_get_attr_value(&tuple->as.join, attr_name);
        else
            assert(false);
    }

    static value_type_t tuple_source_get_attr_value(const tuple_source_t *source, const attr_name_t attr_name)
    {
        const relation_t *relation = source->relation;
        uint16_t attr_i = relation_attr_i_by_name(relation, attr_name);
        return relation_tuple_values_by_id(relation, source->tuple_i)[attr_i];
    }

    static value_type_t tuple_project_get_attr_value(const tuple_project_t *project, const attr_name_t attr_name)
    {
        for (size_t attr_i = 0; attr_i < project->attr_num; attr_i++ )
            if (strcmp(project->attr_names[attr_i], attr_name) == 0)
                return tuple_get_attr_value(project->source_tuple, attr_name);
        assert(false);
    }

    static value_type_t tuple_join_get_attr_value(const tuple_join_t *join, const attr_name_t attr_name)
    {
        if (tuple_has_attr(join->left_source_tuple, attr_name))
            return tuple_get_attr_value(join->left_source_tuple, attr_name);
        else if (tuple_has_attr(join->right_source_tuple, attr_name))
            return tuple_get_attr_value(join->right_source_tuple, attr_name);
        else
            assert(false);
    }

    #+END_SRC

*** Устройство операторов

    Для выполнения запросов PigletQL использует систему, похожую на Volcano. Оператор это три
    основных функции (TODO: link op_open, op_next, op_close) и состояние (state):

    #+BEGIN_SRC c
      /* see pigletql-eval.h */

      /*
       * Operators iterate over relation tuples or tuples returned from other operators using 3 standard
       * ops: open, next, close.
       */
      typedef struct operator_t operator_t;

      typedef void (*op_open)(void *state);
      typedef tuple_t *(*op_next)(void *state);
      typedef void (*op_close)(void *state);
      typedef void (*op_destroy)(operator_t *state);

      /* The operator itself is just 4 pointers to related ops and operator state */
      struct operator_t {
          op_open open;
          op_next next;
          op_close close;
          op_destroy destroy;

          void *state;
      } ;

      /* see pigletql-eval.с */
    #+END_SRC

    Дополнительная функция op_destroy освобождает ресурсы всего дерева операторов целиком. Состояние
    в state - произвольные данные, которые аллоцируются и деаллоциются в функциях op_open/op_close.

    Пример использования простейшего из операторов (scan_op):

    #+BEGIN_SRC c
      /* see pigletql-eval-test.c */

      /* ...relation created... */

      operator_t *scan_op = scan_op_create(relation);

      scan_op->open(scan_op->state);

      size_t tuples_received = 0;
      tuple_t *tuple = NULL;
      while((tuple = scan_op->next(scan_op->state)))
          tuples_received++;

      scan_op->close(scan_op->state);

      scan_op->destroy(scan_op);

    #+END_SRC

    Здесь оператор scan просто извлекает все кортежи из отношения одно за другим, в конце возвращая
    NULL. Интерфейс извлечения кортежей один для всех операторов, отличается только функция создания
    конкретного оператора.

    Давайте разберем код функций оператора scan. Создание оператора:

    #+BEGIN_SRC c
      /* see pigletql-eval.с */

      typedef struct scan_op_state_t {
          /* A reference to the relation being scanned */
          const relation_t *relation;
          /* Next tuple index to retrieve from the relation */
          uint32_t next_tuple_i;
          /* A structure to be filled with references to tuple data */
          tuple_t current_tuple;
      } scan_op_state_t;

      operator_t *scan_op_create(const relation_t *relation)
      {
          operator_t *op = calloc(1, sizeof(*op));
          if (!op)
              goto op_fail;

          scan_op_state_t *state = calloc(1, sizeof(*state));
          if (!state)
              goto state_fail;

          state->relation = relation;
          state->next_tuple_i = 0;
          state->current_tuple.tag = TUPLE_SOURCE;
          state->current_tuple.as.source.tuple_i = 0;
          state->current_tuple.as.source.relation = relation;
          op->state = state;

          op->open = scan_op_open;
          op->next = scan_op_next;
          op->close = scan_op_close;
          op->destroy = scan_op_destroy;

          return op;

      state_fail:
              free(op);
      op_fail:
          return NULL;
      }
    #+END_SRC

    Состояние оператора scan включает в себя указатель на отношение, индекс данных текущего кортежа
    в отношении и структуру tuple_t, содержащую все данные, необходимые для извлечение данных и
    отношения. Главное здесь - сохранение в структуре оператора указателей на соответствующие
    функции оператора.

    При открытии оператора просто обновляется состояние в начальное состояние:

    #+BEGIN_SRC c
      /* see pigletql-eval.с */

      void scan_op_open(void *state)
      {
          scan_op_state_t *op_state = (typeof(op_state)) state;
          op_state->next_tuple_i = 0;
          tuple_t *current_tuple = &op_state->current_tuple;
          current_tuple->as.source.tuple_i = 0;
      }

    #+END_SRC

    Запрос следующего кортежа переключает оператор на следующий кортеж отношения:

    #+BEGIN_SRC c
      /* see pigletql-eval.с */

      tuple_t *scan_op_next(void *state)
      {
          scan_op_state_t *op_state = (typeof(op_state)) state;
          if (op_state->next_tuple_i >= op_state->relation->tuple_num)
              return NULL;
          uint32_t current_i = op_state->next_tuple_i;
          tuple_source_t *source_tuple = &op_state->current_tuple.as.source;
          source_tuple->tuple_i = current_i;

          op_state->next_tuple_i++;

          return &op_state->current_tuple;
      }

    #+END_SRC

    Закрытие оператора возвращает все в изначальное состояние:

    #+BEGIN_SRC c
      /* see pigletql-eval.с */

      void scan_op_close(void *state)
      {
          scan_op_state_t *op_state = (typeof(op_state)) state;
          op_state->next_tuple_i = 0;
          tuple_t *current_tuple = &op_state->current_tuple;
          current_tuple->as.source.tuple_i = 0;
      }

    #+END_SRC

    В случае оператора scan все достаточно просто. Функции открытия и закрытия в других операторах
    работают сложнее. Например, sort при открытии создает временное отношения, копирует в нее
    кортежи из вложенного оператора и сортирует в таком виде. При вызове функции next происходит
    перебор кортежей во временном отношении. Close высвобождает временное отношение.

*** Компиляция запросов в дерево операторов

    Запросы вида CREATE TABLE и INSERT устроены довольно просто, а вот компиляцию SELECT стоит
    обсудить подробней.

    После разбора запроса компилятору на вход подается структура (TODO: link), соответствующая поддерживаемым в
    PigletQL параметрам запросов:

    #+BEGIN_SRC c
      /* see pigletql-parser.h */
      typedef struct query_select_t {
          /* Relation attributes to output */
          attr_name_t attr_names[MAX_ATTR_NUM];
          uint16_t attr_num;

          /* Relations to get tuples from */
          rel_name_t rel_names[MAX_REL_NUM];
          uint16_t rel_num;

          /* Predicates to apply to tuples */
          query_predicate_t predicates[MAX_PRED_NUM];
          uint16_t pred_num;

          /* Pick an attribute to sort by */
          bool has_order;
          attr_name_t order_by_attr;
          sort_order_t order_type;
      }
    #+END_SRC

    Компиляция происходит поэтапно:

    1. В качестве корня дерева операторов определется отношение-источник или сразу несколько
       отношений для объединения (один оператор scan или несколько вложенных пар scan/join).

    2. Выбираются атрибуты для вывода (поверх корня добавляется оператор project).

    3. При наличии предикатов добавляется оператор select.

    4. При указани атрибута сортировки добавляется оператор sort.

    Исходный код можно посмотреть в функции compile_select (TODO: link), он достаточно простой, но несколько
    многословный.

*** Примеры работы интерпретатора

    Создание двух таблиц и их объединение (join):

    #+BEGIN_EXAMPLE
      > ./pigletql
      > create table t1 (a1,a2,a3);
      > create table t2 (a4,a5,a6);
      > insert into t1 values (1,2,3);
      > insert into t2 values (4,5,6);
      > select a1,a2,a3,a4,a5,a6 from t1,t2;
      a1 a2 a3 a4 a5 a6
      1 2 3 4 5 6
      rows: 1
    #+END_EXAMPLE

    На самом деле в PigletQL происходит декартово произведение кортежей из двух отношений (cross
    join):

    #+BEGIN_EXAMPLE
      > ./pigletql
      > create table t1 (a1);
      > create table t2 (a2);
      > insert into t1 values (1);
      > insert into t1 values (2);
      > insert into t2 values (3);
      > insert into t2 values (4);
      > select a1,a2 from t1,t2;
      a1 a2
      1 3
      1 4
      2 3
      2 4
      rows: 4
    #+END_EXAMPLE

    Впрочем, мы можем имитировать и более развитый join:

    #+BEGIN_EXAMPLE
      > ./pigletql
      > create table t1 (id1, val1);
      > create table t2 (id2, val2);
      > insert into t1 values (1,1);
      > insert into t1 values (2,1);
      > insert into t2 values (1, 2);
      > insert into t2 values (2,2);
      > select id1,id2,val1,val2 from t1,t2 where id1=id2;
      id1 id2 val1 val2
      1 1 1 2
      2 2 1 2
      rows: 2
    #+END_EXAMPLE

    Можно и отсортировать результаты:

    #+BEGIN_EXAMPLE
      > ./pigletql
      > create table t1 (id1, val1);
      > insert into t1 values (1,1);
      > insert into t1 values (2,1);
      > select id1,val1 from t1 order by id1 desc;
      id1 val1
      2 1
      1 1
      rows: 2
      > select id1,val1 from t1 order by id1 asc;
      id1 val1
      1 1
      2 1
      rows: 2
    #+END_EXAMPLE

* Новые аппаратные возможности и архитектура реляционных БД

  Интерпретатор PigletQL опирается на те же архитектурные принципы, что и крупные традиционные БД.
  Ограниченность размера ОЗУ относительно объема данных в основном хранилище делали серьезную
  оптимизацию интерпретатора бессмысленной. Но начиная с конца 00-х стоимость памяти и увеличенная
  разрядность серверных процессоров позволяли переносить больше данных в кеш. К 2010-м у
  разработчиков БД появилась позвомжность сделать память /основным/ хранилищем данных^{[[main-memory-db-book]]}.

  В новой схеме все данные располагаются в ОЗУ, а на постоянном хранилище находится только журнал
  изменений, обеспечивающий восстановление данных в случае отказа БД. Тот факт, что из работы
  интерпретатора исключаются долгие операции ввода-вывода, влияет и на работу интерпретатора
  запросов.

  Традиционные локи на ключевых структурах данных уже не позволяют эффективно синхронизировать
  параллельные запросы; а простой интерпретатор, работающий над абстрактным промежуточным
  представлением, потреблял много вычислительных ресурсов процессора и не позволял эффективно
  использовать кэш процессора.

  Исследователи предложили следующие методы оптимизации интерпретаторов:

  1. Индексы и внутренние структуры данных стали /безлоковыми/.

  2. Были предложены методы /векторизации/ обработки запросов^{[[vectorwise-paper]]}.

  3. Активная модель интерпретации (англ. pull-based) предлагалось заменить рассивной (англ.
     push-based), в которой исполнение запроса проводится не от корня, а от листьев дерева
     операторов^{[[push-interpret-paper]]}.

  4. Запросы предварительно стали компилировать в машинный код (косвенно, через компиляцию в C/C++,
     либо через специальное внутреннее представление аналогичное LLVM^{[[main-memory-db-book]]}).

  5. Вместо традиционных индексов на B-деревьях были использованы списки с пропусками (англ. skip
     list) и другие структуры, подходящие для безлоковой реализации.

  6. Даже в традиционных БД стали использовать
     [[https://www.postgresql.org/docs/11/jit.html][динамическую компиляцию выражений]].

  Что интересно, даже в этом новом поколении баз данных SQL сначала преобразуется во внутреннюю
  форму на реляционных операторах, с которой и проводится основная работа интерпретатора (или
  компилятора).

* Выводы

  Какое-то время назад мне довелось работать над небольшой специализированной БД. Система
  использовалась как бэкэнд для пользовательских интерфейсов, где основное требование - быстрая
  обработка трех-четырех видов аналитических запросов. С производительностью проблем не было, но
  архитектура решения оставляла желать лучшего, прежде всего потому что ни я, ни оригинальный
  разработчик системы не были знакомы с опытом разработки больших реляционных баз данных, где все
  наши проблемы давно уже были решены. Любое расширение языка запросов вызывало каскад изменений во
  всем коде базы данных.

  Саму БД со временем пришлось заменить на менее производительную традиционную базу данных.

  Использование внутреннего представления в стиле Volcano могло бы сильно упростить
  внесение изменений в интерпретатор запросов даже без трудоемких компилирующих подсистем или
  оптимизации.

  Со временем у меня дошли руки до изучения архитектуры современных интерпретаторов и компиляторов
  запросов и стало ясно, насколько легко можно было бы решить те проблемы, ознакомься мы вовремя со
  стандартными для области решениями. Некоторые из своих выводов я постарался оформить в этой
  статье и, надеюсь, удалось показать, как именно можно безболезненно организовать исполнение
  запросов.

* TODO Библиография

   - the std implementation book

   - Java implementation book

   - <<link-rel-algebra-paper>> paper introducing relational

   - <<link-sql-history-paper>> paper on the history of SQL

   - <<link-sequel-paper>> first paper on  Sequel/SQL

   - <<link-java-book>>book with a Java-based example

   - <<link-volcano-paper>> paper on volcano-style processing

   - <<link-system-r-paper>> System R paper

   - <<main-memory-db-book>> the main memory db book

   - <<push-interpret-paper>> push-based interpreter model

   - <<vectorwise-paper>> vectorwise paper

   - <<memsql-paper>> MemSQL and compiling: C++ -> .so -> execute
