* DONE Аннотация

  Реляционные базы данных - современный де факто стандарт хранения, обработки и доступа к данным.
  Масштаб таких БД простирается от небольших встроенных в процесс приложения библиотек (TODO:
  SQLite) до распределенных систем в сотни машин (TODO: Hive).

  Внутреннее устройство конкретных баз данных может сильно различаться в зависимости от множества
  факторов: объема данных, требуемой производительностью в видах запросов, некоторых ключевых
  архитектурных решений. Объединяет же эти базы данных только реляционная модель и общий интерфейс
  доступа к данным - язык SQL.

  Данная статья рассматривает основы реляционной алгебры, ее связи с языком SQL, и описывает
  реализацию интерпретатора небольшого диалекта SQL. На базе примера интерпретатора-примера
  объясняются более современные подходы к компиляции и интерпретации SQL.

* DONE Исторический обзор: реляционная алгебра и SQL

  Реляционная модель данных была предложена Эдгаром Коддом в 1970 году (TODO: link) во время работы
  в одной из исследовательских групп компании IBM. Вместе с моделью Кодд разработал язык для работы
  с данными - реляционную алгебру. Модель и сопутствующая алгебра в первые годы после публикации не
  получили распространения в СУБД от IBM.

  Несмотря на это Кодд активно занимался популяризацией своих идей внутри компании, а на одной из
  внутренних корпоративных презентаций с его работами познакомились Реймонд Бойс и Дональд
  Чемберлен, занимавшиеся тогда исследованиями в области языков запросов для СУБД. Идеи Кодда
  показались им перспективными, но слишком ориентированными на математиков. Поэтому ученые занялись
  альтеративным реляционной алгебре языком запросов и результат своих исследований - язык Sequel -
  опубликовали в 1974 году (TODO: link). Позже из-за конфликта имен с других языком программирования
  Sequel получил современное название SQL (TODO: history link).

  Новый язык и соответствующая ему модель данных были выбраны в качестве основных разработчиками еще
  одного проекта IBM - исследовательской СУБД System R (TODO: history link), разработка которой
  велась в середине 70-х. System R стала моделью для множества успешных сторонних коммерческих баз
  данных и собственной реляционной СУБД компании IBM - DB2. Уже в 1984 годы был опубликован первый
  стандарт языка SQL (TODO: link). Язык SQL стал современным стандартом в области работы с данными.

  Модель данных SQL упрощает и видоизменяет исходную реляционную модель данных, за что ее долго
  критиковал сам Кодд; но удивительным образом в современных БД нашли свое место и ключевые элементы
  реляционной алгебры, и декларативный SQL, что можно будет увидеть в интерпретаторе-примере.

* DONE Проблемы традиционных СУБД и традиционные интерпретаторы

  Любая промышленная СУБД решает типовые задачи: управление памятью, проблемы параллельного доступа
  к данным и выполнение запросов пользователей.

  Традиционно производительность БД упирается в скорость чтения данных с медленных накопителей,
  имеющих большие объемы и куда помещаются все пользовательские данные. Быстрое же ОЗУ, с которым
  непосредственно работает процессор, имеет ограниченный объем. Выбором данных для помещения в буфер
  ОЗУ, с которым работает каждый конкретный запрос, в БД занимаются подсистемы управления буфером
  (англ. buffer manager или page cache). В простейших БД эту задачу перекладывают на операционную
  систему при помощи системного вызова mmap.

  В условиях, когда большую часть времени обработки запроса занимает ввод-вывод, не так важна
  производительность выполнения самого запроса, поэтому до недавних пор сами интерпретаторы запросов
  были устроены относительно просто.

  # TODO: a picture

  Например, в типичных СУБД, поддерживающих стандарт SQL, из запроса сначала формируется древовидное
  внутреннее представление в терминах логической алгебры. Логическая алгебра примерно соответствует
  реляционной алгебре Кода, для нее существует множество упрощающих правил и эвристик, которые и
  использует первый этап работы оптимизирующей запросы подсистемы.

  В компиляторах языков общего назначения этому этапу условно соответствуют простейшие оптимизации на
  выражениях (свертка констант, удаление мертвого кода и так далее).

  На втором этапе работы оптимизатора выбираются конкретные алгоритмы, реализующие операторы
  логической алгебры. В результате из представления в форме логической алгебры получается
  представление в виде физической алгебры.

  Физическая алгебра - древовидное представление, которое непосредственно может выполняться
  интерпретатором запросов, без дополнительной обработки.

* DONE Реляционная алгебра на пальцах

  Логическая алгебра, в которую компилируются запросы традиционных БД, во многом схожа с реляционной
  алгеброй Кодд, поэтому для понимания принципов работы интерпретаторов SQL, надо иметь хотя бы
  базовое понимание модели реляционной алгебры.

  Реляционная алгебра состоит из /операторов/, определенных над /отношениями/.

  Отношение представляет собой множество атрибутов (заголовок отношения) и множество /кортежей/.
  Каждый атрибут отношения это пара тип и имя. Все кортежи во множестве кортежей содержат значения
  типов, определенных в соответствующих атрибутах отношений.

  Каждый оператор выполняет действие над одним и более отношениями; результат работы оператора -
  новое отношение.

  В SQL отношения соответствуют - с некоторыми оговорками - таблицам, атрибуты отношений - колонкам,
  а кортежи - рядам в этих таблицах.

  Примеры простейших операторов:

  1. Выборка (англ. select).

  2. Проекция (англ. project).

  3. Переименование (англ. rename).

  4. Объединение (англ. union).

  Аргументы оператора выборки - существующее отношение и предикат на атрибутах отношения. Результат
  работы оператора - новое отношение, для значений атрибутов кортежей которого верен предикат.

  Оператор проекции берет существующее отношение, и возвращает отношение со всеми кортежами, но
  только подмножеством атрибутов.

  Оператор переименования меняет имена атрибутов.

  Оператор объединения, как можно догадаться, объединяет два отношения в одно.

  Естественно, что существует множество других операторов. Некоторые интересные отличия SQL от
  реляционной алгебры: результат работы операторов может быть упорядочен оператором сортировки;
  таблицы - не обязательно множества, то есть значения колонок в разных рядах могут повторяться.

  Простейший запрос:

  SELECT column1 FROM table1 WHERE column1 > 10 ORDER BY column1;

  Соответствующие ему операторы логической алгебры:

  sort(project(select(scan(table1), column1>10), column1), column1)

  Оператор scan просто выбирает кортежи из таблицы table1; select выбирает кортежи, для которых
  верен предикат column1>10; project оставляет в кортежах только атрибут column1, а оператор sort
  возвращает таблицу с упорядоченными по атрибуту column1 рядами.

  TODO: картинка с деревом операторов

* DONE Модель Volcano на итераторах

  После компиляции SQL в дерево операторов логической алгебры, этапа оптимизации и выбора операторов
  физической алгебры получившийся древовидный план запроса надо выполнить. В традиционных БД,
  ориентированных на размещение данных на емких и медленных постоянных носителях, быстрое выполнение
  запроса процессором менее важно, чем сведение к минимуму ввода-вывода. Дерево операторов
  физической алгебры достаточно исполнить без дополнительных преобразований.

  Интерпретаторы дерева физической алгебры в закрытых коммерческих БД использовались практически
  всегда, но ключевая публикация на эту тему связана с экспериментальным оптимизатором Volcano
  (TODO: link), разрабатывавшемся в начале 90-х.

  В модели Volcano операторы превращаются в структуры с тремя функциями: open, next, close. Кроме
  функций оператор содержит рабочее состояние - state. Функция open инициирует состояние оператора,
  next возвращает либо следующий кортеж, либо NULL если кортежей большей не осталось. Функция close
  деаллоцирует рабочее состояние. Каждый оператор, таким образом, перебирает кортежи какого-либо
  постоянно существующего отношения, либо отношения, формируемого перебором кортежей дочерних
  операторов.

  # TODO: picture

  Операторы могут быть вложены друг в друга, чтобы сформировать дерево операторов.

  В сущности, в терминах современных языков высокого уровня дерево таких операторов представляет
  собой каскад интераторов.

* TODO PigletQL

  От модели Volcano отталкиваются даже более развитые интерпретаторы и компиляторы запросов в
  реляционных СУБД, поэтому в качестве иллюстрации к статье я разработал небольшой интерпретатор
  языка запросов, напоминающего SQL - PigletQL.

  Язык этот поддерживает создание таблиц в стиле SQL, но ограничивается единственным типом -
  32-битными положительными целыми числами. Все таблицы располагаются в памяти. Система работает в
  один поток и не предлагает механизма транзакций.

  В PigletQL нет оптимизатора, и запросы select компилируются прямо в дерево операторов.

  К таблицам можно выполнять запросы, соответствующие простейшим операторам физической алгебры: scan,
  project, select, join, sort.

  Пример сессии PigletQL:

  #+BEGIN_EXAMPLE
  > ./pigletql
  > CREATE TABLE tab1 (col1,col2,col3);
  > INSERT INTO tab1 VALUES (1,2,3);
  > INSERT INTO tab1 VALUES (4,5,6);
  > SELECT col1,col2,col3 FROM tab1;
  col1 col2 col3
  1 2 3
  4 5 6
  rows: 2
  > SELECT col1 FROM tab1 ORDER BY col1 DESC;
  col1
  4
  1
  rows: 2
  #+END_EXAMPLE

*** Отношения и кортежи

    Простейшие сущности в PigletQL: отношения (англ. relations) и кортежи (англ. tuples).

    Отношения это плоские таблицы, создаваемые с заданным количеством атрибутов (функция relation_create) или с
    атрибутами, позаимствованными у кортежа (функция relation_create_for_tuple):

    #+BEGIN_SRC c

      /* see pigletql-eval.h */
      typedef struct relation_t relation_t;

      relation_t *relation_create(const attr_name_t *attr_names, const uint16_t attr_num);

      relation_t *relation_create_for_tuple(const tuple_t *tuple);

      /* see pigletql-eval.c */
      struct relation_t {
          attr_name_t attr_names[MAX_ATTR_NUM];
          uint16_t attr_num;

          value_type_t *tuples;
          uint32_t tuple_num;
          uint32_t tuple_slots;
      };

    #+END_SRC

    Кортежи устроены несколько сложнее, напрямую их создать нельзя, а можно только получить из
    оператора, перебирающего кортежи либо отношения-источника, либо вложенного оператора:

    #+BEGIN_SRC c
      /* see pigletql-eval.h */
      typedef struct tuple_t tuple_t;

      /* see pigletql-eval.c */

      typedef enum tuple_tag {
          TUPLE_SOURCE,
          TUPLE_PROJECT,
          TUPLE_JOIN
      } tuple_tag;

      /* A unified tuple type passed between operators */
      struct tuple_t {
          tuple_tag tag;
          union {
              tuple_source_t source;
              tuple_project_t project;
              tuple_join_t join;
          } as;
      };

      /* Source tuple is a reference to raw data in the relations */
      typedef struct tuple_source_t {
          /* A reference to a relation containing the tuple */
          const relation_t *relation;
          /* A reference to the values in the relation containing the tuple */
          uint32_t tuple_i;
      } tuple_source_t;

      /* A projected tuple is a reference to another tuple giving access to a subset of referenced tuple
       * attributes only */
      typedef struct tuple_project_t {
          /* a reference to tuple to project attributes from  */
          tuple_t *source_tuple;
          /* projected attributes */
          attr_name_t attr_names[MAX_ATTR_NUM];
          uint16_t attr_num;
      } tuple_project_t;

      /* A joined tuple is a tuple containing attributes from 2 source tuples  */
      typedef struct tuple_join_t {
          /* Contained tuples to join attributes from */
          tuple_t *left_source_tuple;
          tuple_t *right_source_tuple;
      } tuple_join_t;

    #+END_SRC

    Кортежи в PigletQL бывают трех видов: ссылающиеся на данные в отношении (tuple_source_t),
    ограничивающие список доступных атрибутов (tuple_project_t) и соединяющие атрибуты из двух
    вложенных кортежей (tuple_join_t). Функции, обращающиеся к значениями атрибутов, работают
    по-разному для каждого из видов кортежей в зависимости от тэга кортежа.

    Вот, например, функция, получающее значение атрибута в кортеже:

    #+BEGIN_SRC c
    /* see pigletql-eval.h */

    value_type_t tuple_get_attr_value(const tuple_t *tuple, const attr_name_t attr_name);

    /* see pigletql-eval.c */

    value_type_t tuple_get_attr_value(const tuple_t *tuple, const attr_name_t attr_name)
    {
        if (tuple->tag == TUPLE_SOURCE)
            return tuple_source_get_attr_value(&tuple->as.source, attr_name);
        else if (tuple->tag == TUPLE_PROJECT)
            return tuple_project_get_attr_value(&tuple->as.project, attr_name);
        else if (tuple->tag == TUPLE_JOIN)
            return tuple_join_get_attr_value(&tuple->as.join, attr_name);
        else
            assert(false);
    }

    static value_type_t tuple_source_get_attr_value(const tuple_source_t *source, const attr_name_t attr_name)
    {
        const relation_t *relation = source->relation;
        uint16_t attr_i = relation_attr_i_by_name(relation, attr_name);
        return relation_tuple_values_by_id(relation, source->tuple_i)[attr_i];
    }

    static value_type_t tuple_project_get_attr_value(const tuple_project_t *project, const attr_name_t attr_name)
    {
        for (size_t attr_i = 0; attr_i < project->attr_num; attr_i++ )
            if (strcmp(project->attr_names[attr_i], attr_name) == 0)
                return tuple_get_attr_value(project->source_tuple, attr_name);
        assert(false);
    }

    static value_type_t tuple_join_get_attr_value(const tuple_join_t *join, const attr_name_t attr_name)
    {
        if (tuple_has_attr(join->left_source_tuple, attr_name))
            return tuple_get_attr_value(join->left_source_tuple, attr_name);
        else if (tuple_has_attr(join->right_source_tuple, attr_name))
            return tuple_get_attr_value(join->right_source_tuple, attr_name);
        else
            assert(false);
    }

    #+END_SRC

*** DONE Операторы

    Для выполнения запросов PigletQL использует систему, похожую на Volcano. Оператор это три
    основных функции (op_open, op_next, op_close) и состояние (state):

    #+BEGIN_SRC c
      /* see pigletql-eval.h */

      /*
       * Operators iterate over relation tuples or tuples returned from other operators using 3 standard
       * ops: open, next, close.
       */
      typedef struct operator_t operator_t;

      typedef void (*op_open)(void *state);
      typedef tuple_t *(*op_next)(void *state);
      typedef void (*op_close)(void *state);
      typedef void (*op_destroy)(operator_t *state);

      /* The operator itself is just 4 pointers to related ops and operator state */
      struct operator_t {
          op_open open;
          op_next next;
          op_close close;
          op_destroy destroy;

          void *state;
      } ;

      /* see pigletql-eval.с */
    #+END_SRC

    Дополнительная функция op_destroy освобождает ресурсы всего дерева операторов целиком. Состояние
    в state - произвольные данные, которые аллоцируются и деаллоциются в функциях op_open/op_close.

    Пример использования простейшего из операторов (scan_op):

    #+BEGIN_SRC c
      /* see pigletql-eval-test.c */

      /* ...relation created... */

      operator_t *scan_op = scan_op_create(relation);

      scan_op->open(scan_op->state);

      size_t tuples_received = 0;
      tuple_t *tuple = NULL;
      while((tuple = scan_op->next(scan_op->state)))
          tuples_received++;

      scan_op->close(scan_op->state);

      scan_op->destroy(scan_op);

    #+END_SRC

    Здесь оператор scan просто извлекает все кортежи из отношения одно за другим, в конце возвращая
    NULL. Интерфейс извлечения кортежей един для всех операторов, отличается только функция создания
    конкретного оператора.

*** TODO Компиляция запросов в дерево операторов

  - operator system

  - op examples: scan op, project op, select op, join op, sort op

  - compiling select queries

  - running other requests (create/insert)

* TODO Новые аппаратные возможности и архитектура реляционных БД

  - RAM can be huge now so buffer management is not always needed

  - anti-caching proposal and examples

  - non-volatile storage, i.e. hard disks, SSDs a newer types of memory

* TODO Альтернативные подходы к интерпретации запросов

  - push-based model

  - vectorized query execution

* TODO Динамическая компиляция запросов

  - MemSQL and compiling: C++ -> .so -> execute

  - PostgreSQL jit query compilation
* TODO Библиография

  - paper on the history of SQL

  - book with a Java-based example

  - the std implementation book

  - System R paper

  - PostgreSQL links and comments on older versions

  - paper introducing relational algebra

  - anti-caching paper

  - paper on traditional query evaluation

  - paper on volcano-style processing

  - PostgreSQL jit compilation

  - SQLite

  - push-based interpreter model

  - vectorwise paper

  - compiling queries papers
