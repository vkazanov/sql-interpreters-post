* DONE Аннотация

  Реляционные базы данных - современный де факто стандарт хранения, обработки и доступа к данным.
  Масштаб таких БД простирается от небольших встроенных в процесс приложения библиотек (TODO:
  SQLite) до распределенных систем в сотни машин (TODO: Hive).

  Внутреннее устройство конкретных баз данных может сильно различаться в зависимости от множества
  факторов: объема данных, требуемой производительностью в видах запросов, некоторых ключевых
  архитектурных решений. Объединяет же эти базы данных только реляционная модель и общий интерфейс
  доступа к данным - язык SQL.

  Данная статья рассматривает основы реляционной алгебры, ее связи с языком SQL, и описывает
  реализацию интерпретатора небольшого диалекта SQL. На базе примера интерпретатора-примера
  объясняются более современные подходы к компиляции и интерпретации SQL.

* DONE Исторический обзор: реляционная алгебра и SQL

  Реляционная модель данных была предложена Эдгаром Коддом в 1970 году (TODO: link) во время работы
  в одной из исследовательских групп компании IBM. Вместе с моделью Кодд разработал язык для работы
  с данными - реляционную алгебру. Модель и сопутствующая алгебра в первые годы после публикации не
  получили распространения в СУБД от IBM.

  Несмотря на это Кодд активно занимался популяризацией своих идей внутри компании, а на одной из
  внутренних корпоративных презентаций с его работами познакомились Реймонд Бойс и Дональд
  Чемберлен, занимавшиеся тогда исследованиями в области языков запросов для СУБД. Идеи Кодда
  показались им перспективными, но слишком ориентированными на математиков. Поэтому ученые занялись
  альтеративным реляционной алгебре языком запросов и результат своих исследований - язык Sequel -
  опубликовали в 1974 году (TODO: link). Позже из-за конфликта имен с других языком программирования
  Sequel получил современное название SQL (TODO: history link).

  Новый язык и соответствующая ему модель данных были выбраны в качестве основных разработчиками еще
  одного проекта IBM - исследовательской СУБД System R (TODO: history link), разработка которой
  велась в середине 70-х. System R стала моделью для множества успешных сторонних коммерческих баз
  данных и собственной реляционной СУБД компании IBM - DB2. Уже в 1984 годы был опубликован первый
  стандарт языка SQL (TODO: link). Язык SQL стал современным стандартом в области работы с данными.

  Модель данных SQL упрощает и видоизменяет исходную реляционную модель данных, за что ее долго
  критиковал сам Кодд; но удивительным образом в современных БД нашли свое место и ключевые элементы
  реляционной алгебры, и декларативный SQL, что можно будет увидеть в интерпретаторе-примере.

* DONE Проблемы традиционных СУБД и традиционные интерпретаторы

  Любая промышленная СУБД решает типовые задачи: управление памятью, проблемы параллельного доступа
  к данным и выполнение запросов пользователей.

  Традиционно производительность БД упирается в скорость чтения данных с медленных накопителей,
  имеющих большие объемы и куда помещаются все пользовательские данные. Быстрое же ОЗУ, с которым
  непосредственно работает процессор, имеет ограниченный объем. Выбором данных для помещения в буфер
  ОЗУ, с которым работает каждый конкретный запрос, в БД занимаются подсистемы управления буфером
  (англ. buffer manager или page cache). В простейших БД эту задачу перекладывают на операционную
  систему при помощи системного вызова mmap.

  В условиях, когда большую часть времени обработки запроса занимает ввод-вывод, не так важна
  производительность выполнения самого запроса, поэтому до недавних пор сами интерпретаторы запросов
  были устроены относительно просто.

  # TODO: a picture

  Например, в типичных СУБД, поддерживающих стандарт SQL, из запроса сначала формируется древовидное
  внутреннее представление в терминах логической алгебры. Логическая алгебра примерно соответствует
  реляционной алгебре Кода, для нее существует множество упрощающих правил и эвристик, которые и
  использует первый этап работы оптимизирующей запросы подсистемы.

  В компиляторах языков общего назначения этому этапу условно соответствуют простейшие оптимизации на
  выражениях (свертка констант, удаление мертвого кода и так далее).

  На втором этапе работы оптимизатора выбираются конкретные алгоритмы, реализующие операторы
  логической алгебры. В результате из представления в форме логической алгебры получается
  представление в виде физической алгебры.

  Физическая алгебра - древовидное представление, которое непосредственно может выполняться
  интерпретатором запросов, без дополнительной обработки.

* DONE Реляционная алгебра на пальцах

  Логическая алгебра, в которую компилируются запросы традиционных БД, во многом схожа с реляционной
  алгеброй Кодд, поэтому для понимания принципов работы интерпретаторов SQL, надо иметь хотя бы
  базовое понимание модели реляционной алгебры.

  Реляционная алгебра состоит из /операторов/, определенных над /отношениями/.

  Отношение представляет собой множество атрибутов (заголовок отношения) и множество /кортежей/.
  Каждый атрибут отношения это пара тип и имя. Все кортежи во множестве кортежей содержат значения
  типов, определенных в соответствующих атрибутах отношений.

  Каждый оператор выполняет действие над одним и более отношениями; результат работы оператора -
  новое отношение.

  В SQL отношения соответствуют - с некоторыми оговорками - таблицам, атрибуты отношений - колонкам,
  а кортежи - рядам в этих таблицах.

  Примеры простейших операторов:

  1. Выборка (англ. select).

  2. Проекция (англ. project).

  3. Переименование (англ. rename).

  4. Объединение (англ. union).

  Аргументы оператора выборки - существующее отношение и предикат на атрибутах отношения. Результат
  работы оператора - новое отношение, для значений атрибутов кортежей которого верен предикат.

  Оператор проекции берет существующее отношение, и возвращает отношение со всеми кортежами, но
  только подмножеством атрибутов.

  Оператор переименования меняет имена атрибутов.

  Оператор объединения, как можно догадаться, объединяет два отношения в одно.

  Естественно, что существует множество других операторов. Некоторые интересные отличия SQL от
  реляционной алгебры: результат работы операторов может быть упорядочен оператором сортировки;
  таблицы - не обязательно множества, то есть значения колонок в разных рядах могут повторяться.

  Простейший запрос:

  SELECT column1 FROM table1 WHERE column1 > 10 ORDER BY column1;

  Соответствующие ему операторы логической алгебры:

  sort(project(select(scan(table1), column1>10), column1), column1)

  Оператор scan просто выбирает кортежи из таблицы table1; select выбирает кортежи, для которых
  верен предикат column1>10; project оставляет в кортежах только атрибут column1, а оператор sort
  возвращает таблицу с упорядоченными по атрибуту column1 рядами.

  TODO: картинка с деревом операторов

* TODO Модель Volcano на итераторах

  - cheap CPU and expensive IO leads

  - the canonical paper

  - the iterator cascade idea

* TODO Интерпретатор-пример

  - relations, relation attributes and tuples

  - scan op

  - project op

  - select op

  - join op

  - sort op

  - compiling select queries

* TODO Новые аппаратные возможности и архитектура реляционных БД

  - RAM can be huge now so buffer management is not always needed

  - anti-caching proposal and examples

  - non-volatile storage, i.e. hard disks, SSDs a newer types of memory

* TODO Альтернативные подходы к интерпретации запросов

  - push-based model

  - vectorized query execution

* TODO Динамическая компиляция запросов

  - MemSQL and compiling: C++ -> .so -> execute

  - PostgreSQL jit query compilation
* TODO Библиография

  - paper on the history of SQL

  - book with a Java-based example

  - the std implementation book

  - System R paper

  - PostgreSQL links and comments on older versions

  - paper introducing relational algebra

  - anti-caching paper

  - paper on traditional query evaluation

  - paper on volcano-style processing

  - PostgreSQL jit compilation

  - SQLite

  - push-based interpreter model

  - vectorwise paper

  - compiling queries papers
